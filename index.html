<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Telekinesis: FINAL</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: monospace; }
        
        /* UI Overlay */
        #start-screen {
            position: absolute; width: 100%; height: 100%; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 50;
        }
        button {
            padding: 20px 40px; background: transparent; border: 2px solid #0f0; 
            color: #0f0; font-size: 18px; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 20px #00ff0055;
        }
        
        /* Hidden Video (Must be technically 'visible' for AI to work) */
        #input-video {
            position: absolute; top: 0; left: 0; width: 10px; height: 10px; opacity: 0; z-index: -1;
        }

        /* Status HUD */
        #hud {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: #00ffcc; font-size: 12px; pointer-events: none; opacity: 0.5;
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="color:white; margin-bottom: 20px;">TELEKINESIS ENGINE</h1>
        <button onclick="activateSystem()">ACTIVATE LINK</button>
    </div>

    <div id="hud">SYSTEM: WAITING FOR INPUT...</div>
    <video id="input-video" playsinline muted autoplay></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- CONFIGURATION ---
        let scene, camera, renderer, crystal, core;
        let targetPos = { x: 0, y: 0 };
        let targetScale = 1;
        let isPinching = false;

        async function activateSystem() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('hud').innerText = "SYSTEM: CALIBRATING...";

            // 1. Setup Three.js Scene
            initGraphics();

            // 2. Setup Camera
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 640, height: 480 }
                });
                const video = document.getElementById('input-video');
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    initAI(video);
                };
            } catch (e) {
                alert("Camera Error: " + e.message);
            }
        }

        function initGraphics() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Create the Crystal Object
            const group = new THREE.Group();

            // Outer Shell
            const geo1 = new THREE.IcosahedronGeometry(6, 1);
            const mat1 = new THREE.MeshBasicMaterial({ color: 0x00ffcc, wireframe: true, transparent: true, opacity: 0.4 });
            crystal = new THREE.Mesh(geo1, mat1);
            group.add(crystal);

            // Inner Core
            const geo2 = new THREE.OctahedronGeometry(3, 0);
            const mat2 = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: false });
            core = new THREE.Mesh(geo2, mat2);
            group.add(core);

            scene.add(group);
            window.teleObject = group; // Global reference

            animate();
        }

        function initAI(videoElement) {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0, // Fastest for mobile
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            const cam = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cam.start();
            document.getElementById('hud').innerText = "SYSTEM: ONLINE - RAISE HAND";
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks.length > 0) {
                const h = results.multiHandLandmarks[0];
                const index = h[8];  // Index Tip
                const thumb = h[4];  // Thumb Tip

                // 1. FLY: Map hand position to screen coordinates
                // (Multiplier 40 makes it move across the whole screen)
                targetPos.x = (0.5 - index.x) * 40; 
                targetPos.y = (0.5 - index.y) * 40;

                // 2. PINCH: Distance between thumb and index
                const dist = Math.hypot(index.x - thumb.x, index.y - thumb.y);

                if (dist < 0.05) {
                    // SQUEEZE MODE
                    if (!isPinching) {
                        // Trigger Vibration ONCE when pinch starts
                        if(navigator.vibrate) navigator.vibrate(50);
                        isPinching = true;
                    }
                    targetScale = 0.5; // Shrink
                    core.material.color.setHex(0xff0055); // Red Core
                    crystal.rotation.z += 0.2; // Spin fast
                } else {
                    // HOVER MODE
                    isPinching = false;
                    // Map distance to size (Open hand = Big)
                    targetScale = Math.min(Math.max(dist * 5, 0.5), 2.0);
                    core.material.color.setHex(0x00ffff); // Blue Core
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (window.teleObject) {
                // Smooth Physics (Lerp)
                // Move towards hand
                window.teleObject.position.x += (targetPos.x - window.teleObject.position.x) * 0.1;
                window.teleObject.position.y += (targetPos.y - window.teleObject.position.y) * 0.1;
                
                // Scale smoothly
                window.teleObject.scale.x += (targetScale - window.teleObject.scale.x) * 0.1;
                window.teleObject.scale.y += (targetScale - window.teleObject.scale.y) * 0.1;
                window.teleObject.scale.z += (targetScale - window.teleObject.scale.z) * 0.1;

                // Idle Rotation
                crystal.rotation.x += 0.005;
                crystal.rotation.y += 0.005;
            }
            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
