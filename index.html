<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telekinesis Engine</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #overlay {
            position: absolute; width: 100%; height: 100%; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }
        button {
            padding: 20px 50px; background: none; border: 2px solid #00ffcc;
            color: #00ffcc; font-weight: bold; cursor: pointer; letter-spacing: 2px;
        }
        #status {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: #444; font-size: 10px; letter-spacing: 1px; pointer-events: none;
        }
        /* Hidden video */
        #v { position: absolute; visibility: hidden; pointer-events: none; }
    </style>
</head>
<body>

<div id="overlay">
    <button onclick="startTelekinesis()">GRANT ACCESS & START</button>
</div>
<div id="status">NEURAL LINK: STANDBY</div>
<video id="v" playsinline></video>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';

let scene, camera, renderer, crystal;
let targetPos = new THREE.Vector3(0, 0, 0);
let targetScale = new THREE.Vector3(1, 1, 1);
let targetRotation = new THREE.Euler();

window.startTelekinesis = async () => {
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('status').innerText = "NEURAL LINK: ACTIVE";
    
    // 1. Scene Setup
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 20;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // 2. The "Attractive" Object: An Icosahedron (Crystal)
    const geometry = new THREE.IcosahedronGeometry(5, 0); // Low-poly for minimal look
    const material = new THREE.MeshPhongMaterial({
        color: 0x00ffcc,
        wireframe: true,
        emissive: 0x004433,
        shininess: 100
    });
    crystal = new THREE.Mesh(geometry, material);
    scene.add(crystal);

    // Lighting
    const light = new THREE.PointLight(0xffffff, 1, 100);
    light.position.set(10, 10, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x222222));

    // 3. Hand Tracking
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7 });
    
    hands.onResults(results => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const h1 = results.multiHandLandmarks[0];
            
            // FLY: Move object based on index finger position
            targetPos.x = (0.5 - h1[8].x) * 40;
            targetPos.y = (0.5 - h1[8].y) * 30;

            // SQUEEZE / TEAR: Use distance between thumb and index
            const pinchDist = Math.hypot(h1[4].x - h1[8].x, h1[4].y - h1[8].y);
            
            if (results.multiHandLandmarks.length === 1) {
                // Single hand zoom/scale
                let s = THREE.MathUtils.mapLinear(pinchDist, 0.05, 0.4, 0.5, 3);
                targetScale.set(s, s, s);
            } else {
                // Two hand "Tear" logic
                const h2 = results.multiHandLandmarks[1];
                const handDist = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                targetScale.set(handDist * 10, 1, 1); // Stretches on X axis
            }
            
            // ROTATE: Based on wrist to middle finger angle
            targetRotation.z = Math.atan2(h1[12].y - h1[0].y, h1[12].x - h1[0].x);
        }
    });

    const v = document.getElementById('v');
    const cam = new Camera(v, {
        onFrame: async () => { await hands.send({image: v}); },
        width: 640, height: 480
    });
    cam.start();
    animate();
};

function animate() {
    requestAnimationFrame(animate);
    
    // Smooth Interpolation (The "Weight" of Telekinesis)
    crystal.position.lerp(targetPos, 0.1);
    crystal.scale.lerp(targetScale, 0.1);
    crystal.rotation.z += (targetRotation.z - crystal.rotation.z) * 0.1;
    
    // Idle floating animation
    crystal.rotation.y += 0.01;
    
    renderer.render(scene, camera);
}
</script>
</body>
</html>
