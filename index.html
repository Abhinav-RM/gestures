<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo Particle Morph</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Courier New', monospace; }
        #start-screen {
            position: absolute; width: 100%; height: 100%; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
        }
        button {
            padding: 15px 40px; background: #00ffcc; border: none; border-radius: 4px;
            font-weight: bold; cursor: pointer; box-shadow: 0 0 20px #00ffcc55;
        }
        #ui-panel {
            position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 10;
        }
        .stat { color: #00ffcc; font-size: 0.9rem; margin-bottom: 5px; }
        video { position: absolute; bottom: 10px; right: 10px; width: 100px; height: 75px; border-radius: 5px; opacity: 0.6; transform: scaleX(-1); }
    </style>
</head>
<body>

<div id="start-screen">
    <h1>ECHO PARTICLE SYSTEM</h1>
    <p>Hand-Tracked 3D Environment</p>
    <button onclick="init()">INITIALIZE</button>
</div>

<div id="ui-panel">
    <div class="stat">MODE: <span id="current-shape">SPHERE</span></div>
    <div class="stat">GESTURE: <span id="gesture-info">WAITING...</span></div>
</div>

<video id="webcam" playsinline muted></video>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

const PARTICLE_COUNT = 8000; 
let scene, camera, renderer, particles, geometry;
let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
let currentPositions = new Float32Array(PARTICLE_COUNT * 3);
let morphSpeed = 0.08;
let shapeIndex = 0;
let lastFistTime = 0;

// --- 1. Shape Generators ---
const shapes = {
    Sphere: () => {
        const data = new Float32Array(PARTICLE_COUNT * 3);
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            data[i*3] = 10 * Math.cos(theta) * Math.sin(phi);
            data[i*3+1] = 10 * Math.sin(theta) * Math.sin(phi);
            data[i*3+2] = 10 * Math.cos(phi);
        }
        return data;
    },
    Heart: () => {
        const data = new Float32Array(PARTICLE_COUNT * 3);
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const t = Math.random() * Math.PI * 2;
            data[i*3] = 0.6 * (16 * Math.pow(Math.sin(t), 3));
            data[i*3+1] = 0.6 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
            data[i*3+2] = (Math.random() - 0.5) * 5;
        }
        return data;
    },
    Saturn: () => {
        const data = new Float32Array(PARTICLE_COUNT * 3);
        for(let i=0; i<PARTICLE_COUNT; i++) {
            if(i < PARTICLE_COUNT * 0.4) { // Planet
                const phi = Math.random() * Math.PI;
                const theta = Math.random() * Math.PI * 2;
                data[i*3] = 6 * Math.sin(phi) * Math.cos(theta);
                data[i*3+1] = 6 * Math.sin(phi) * Math.sin(theta);
                data[i*3+2] = 6 * Math.cos(phi);
            } else { // Rings
                const angle = Math.random() * Math.PI * 2;
                const r = 8 + Math.random() * 6;
                data[i*3] = r * Math.cos(angle);
                data[i*3+1] = (Math.random() - 0.5) * 0.5;
                data[i*3+2] = r * Math.sin(angle);
            }
        }
        return data;
    }
};

const shapeKeys = Object.keys(shapes);

window.init = async () => {
    document.getElementById('start-screen').style.display = 'none';
    const video = document.getElementById('webcam');
    
    // Three.js Setup
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Particle Geometry
    geometry = new THREE.BufferGeometry();
    const startData = shapes.Sphere();
    currentPositions.set(startData);
    targetPositions.set(startData);
    geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
    
    const mat = new THREE.PointsMaterial({ size: 0.2, color: 0x00ffcc, transparent: true, opacity: 0.8 });
    particles = new THREE.Points(geometry, mat);
    scene.add(particles);

    // MediaPipe
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
    hands.onResults(onResults);

    const cam = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 640, height: 480
    });
    cam.start();
    animate();
};

function onResults(results) {
    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
    const hand = results.multiHandLandmarks[0];

    // 1. Rotation (Index Tip - Landmark 8)
    particles.rotation.y = (0.5 - hand[8].x) * 2;
    particles.rotation.x = (hand[8].y - 0.5) * 2;

    // 2. Pinch to Expand (Thumb Tip [4] to Index Tip [8])
    const dist = Math.hypot(hand[4].x - hand[8].x, hand[4].y - hand[8].y);
    const scale = THREE.MathUtils.mapLinear(dist, 0.05, 0.3, 1, 3);
    particles.scale.setScalar(scale);

    // 3. Fist to Change Shape (Tips to Wrist [0])
    const wrist = hand[0];
    const isFist = [8, 12, 16, 20].every(tip => Math.hypot(hand[tip].x - wrist.x, hand[tip].y - wrist.y) < 0.2);
    
    if (isFist && Date.now() - lastFistTime > 1500) {
        shapeIndex = (shapeIndex + 1) % shapeKeys.length;
        targetPositions.set(shapes[shapeKeys[shapeIndex]]());
        document.getElementById('current-shape').innerText = shapeKeys[shapeIndex];
        lastFistTime = Date.now();
    }
}

function animate() {
    requestAnimationFrame(animate);
    const pos = geometry.attributes.position.array;
    for (let i = 0; i < pos.length; i++) {
        pos[i] += (targetPositions[i] - pos[i]) * morphSpeed;
    }
    geometry.attributes.position.needsUpdate = true;
    renderer.render(scene, camera);
}
</script>
</body>
</html>
