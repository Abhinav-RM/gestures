<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Finger Shooter</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Prevent scroll on mobile */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* The Camera Feed */
        #input-video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
            z-index: 1;
        }

        /* The Game Layer */
        #output-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 2;
            transform: scaleX(-1); /* Mirror canvas to match video */
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none; /* Let clicks pass through */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-text {
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-size: 24px;
            font-weight: bold;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            pointer-events: auto;
        }

        h1 {
            color: #fff;
            font-size: 40px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #f0f;
        }

        p {
            color: #ccc;
            font-size: 16px;
            max-width: 80%;
            line-height: 1.5;
        }

        button {
            background: #0ff;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            color: #000;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 0 20px #0ff;
            transition: transform 0.2s;
        }

        button:active {
            transform: scale(0.95);
        }

        /* Loading Spinner */
        .loader {
            border: 5px solid #333;
            border-top: 5px solid #0ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            display: none;
            margin-top: 20px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="game-container">
    <video id="input-video" playsinline></video>
    <canvas id="output-canvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud-text">SCORE: <span id="score">0</span></div>
        <div class="hud-text" style="text-align: right; font-size: 14px;">PINCH TO SHOOT</div>
    </div>

    <div id="start-screen">
        <h1>NEON FINGER</h1>
        <p>1. Point your index finger to AIM.<br>2. Pinch (Thumb + Index) to SHOOT.<br>3. Allow Camera access to start.</p>
        <button id="start-btn">START MISSION</button>
        <div class="loader" id="loader"></div>
        <p id="status-msg" style="margin-top: 10px; font-size: 12px; color: #666;"></p>
    </div>
</div>

<script>
    // --- Configuration ---
    const VIDEO_Element = document.getElementById('input-video');
    const CANVAS_Element = document.getElementById('output-canvas');
    const CTX = CANVAS_Element.getContext('2d');
    const START_BTN = document.getElementById('start-btn');
    const LOADER = document.getElementById('loader');
    const SCORE_EL = document.getElementById('score');
    const START_SCREEN = document.getElementById('start-screen');
    const STATUS_MSG = document.getElementById('status-msg');

    let score = 0;
    let gameActive = false;
    let lastShotTime = 0;
    
    // Game Objects
    let balloons = [];
    let particles = [];
    let fingerX = 0;
    let fingerY = 0;
    let isPinching = false;

    // Audio Context
    let audioCtx;

    // --- Audio System (Synthesizer) ---
    function initAudio() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
    }

    function playShootSound() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(880, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(110, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    }

    function playPopSound() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    }

    // --- Game Logic ---

    class Balloon {
        constructor() {
            this.reset();
        }

        reset() {
            this.radius = 30 + Math.random() * 20;
            this.x = Math.random() * CANVAS_Element.width;
            this.y = CANVAS_Element.height + this.radius;
            this.speed = 1 + Math.random() * 2;
            this.wobble = Math.random() * Math.PI * 2;
            this.hue = Math.floor(Math.random() * 360);
            this.active = true;
        }

        update() {
            if (!this.active) return;
            this.y -= this.speed;
            this.x += Math.sin(this.y * 0.01 + this.wobble) * 0.5;

            // Reset if goes off top
            if (this.y < -this.radius) {
                this.reset();
            }
        }

        draw() {
            if (!this.active) return;
            CTX.beginPath();
            CTX.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            CTX.fillStyle = `hsla(${this.hue}, 70%, 60%, 0.8)`;
            CTX.fill();
            // Shine
            CTX.beginPath();
            CTX.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
            CTX.fillStyle = 'rgba(255,255,255,0.4)';
            CTX.fill();
        }
    }

    class Particle {
        constructor(x, y, hue) {
            this.x = x;
            this.y = y;
            this.hue = hue;
            this.angle = Math.random() * Math.PI * 2;
            this.speed = Math.random() * 5 + 2;
            this.life = 1.0;
        }

        update() {
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
            this.life -= 0.05;
        }

        draw() {
            CTX.globalAlpha = this.life;
            CTX.fillStyle = `hsl(${this.hue}, 100%, 50%)`;
            CTX.beginPath();
            CTX.arc(this.x, this.y, 3, 0, Math.PI * 2);
            CTX.fill();
            CTX.globalAlpha = 1.0;
        }
    }

    // Initialize Balloons
    for (let i = 0; i < 5; i++) {
        balloons.push(new Balloon());
    }

    function checkCollisions() {
        balloons.forEach(b => {
            if (!b.active) return;
            const dx = fingerX - b.x;
            const dy = fingerY - b.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < b.radius) {
                // POP!
                playPopSound();
                b.active = false;
                score += 10;
                SCORE_EL.innerText = score;
                
                // Spawn particles
                for (let i = 0; i < 10; i++) {
                    particles.push(new Particle(b.x, b.y, b.hue));
                }

                // Respawn balloon after delay
                setTimeout(() => b.reset(), 1000);
            }
        });
    }

    function drawGame() {
        // Clear canvas (but keep transparent to see video)
        CTX.clearRect(0, 0, CANVAS_Element.width, CANVAS_Element.height);

        // Draw Balloons
        balloons.forEach(b => {
            b.update();
            b.draw();
        });

        // Draw Particles
        particles.forEach((p, index) => {
            p.update();
            p.draw();
            if (p.life <= 0) particles.splice(index, 1);
        });

        // Draw Crosshair (at finger position)
        if (fingerX !== 0 && fingerY !== 0) {
            CTX.strokeStyle = isPinching ? '#f00' : '#0ff';
            CTX.lineWidth = 3;
            CTX.beginPath();
            CTX.arc(fingerX, fingerY, 20, 0, Math.PI * 2);
            CTX.stroke();
            
            // Cross lines
            CTX.beginPath();
            CTX.moveTo(fingerX - 30, fingerY);
            CTX.lineTo(fingerX + 30, fingerY);
            CTX.moveTo(fingerX, fingerY - 30);
            CTX.lineTo(fingerX, fingerY + 30);
            CTX.stroke();

            if (isPinching) {
                // Muzzle flash visual
                CTX.fillStyle = 'rgba(255, 50, 50, 0.5)';
                CTX.beginPath();
                CTX.arc(fingerX, fingerY, 40, 0, Math.PI * 2);
                CTX.fill();
            }
        }
        
        requestAnimationFrame(drawGame);
    }


    // --- MediaPipe Setup ---
    
    function onResults(results) {
        if (!gameActive) return;

        // Ensure canvas matches video size
        CANVAS_Element.width = VIDEO_Element.videoWidth;
        CANVAS_Element.height = VIDEO_Element.videoHeight;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // Get Index Finger Tip (Landmark 8)
            // Note: MediaPipe coords are 0.0 - 1.0 normalized
            fingerX = landmarks[8].x * CANVAS_Element.width;
            fingerY = landmarks[8].y * CANVAS_Element.height;

            // Get Thumb Tip (Landmark 4) for pinch detection
            const thumbX = landmarks[4].x * CANVAS_Element.width;
            const thumbY = landmarks[4].y * CANVAS_Element.height;

            // Calculate distance for pinch
            const dist = Math.hypot(fingerX - thumbX, fingerY - thumbY);
            
            // Pinch Threshold (adjust based on testing)
            const pinchThreshold = 40; 

            if (dist < pinchThreshold) {
                if (!isPinching) {
                    // Trigger Start
                    isPinching = true;
                    playShootSound();
                    checkCollisions();
                }
            } else {
                isPinching = false;
            }
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // --- Initialization & Camera ---

    async function startCamera() {
        try {
            const camera = new Camera(VIDEO_Element, {
                onFrame: async () => {
                    await hands.send({image: VIDEO_Element});
                },
                width: 1280,
                height: 720
            });
            await camera.start();
            
            STATUS_MSG.innerText = "Camera Active. Tracking Hands...";
            LOADER.style.display = "none";
            START_SCREEN.style.display = "none";
            gameActive = true;
            drawGame(); // Start Loop

        } catch (error) {
            console.error(error);
            STATUS_MSG.innerText = "Error: " + error.message;
            LOADER.style.display = "none";
            START_BTN.style.display = "block";
        }
    }

    START_BTN.addEventListener('click', () => {
        START_BTN.style.display = "none";
        LOADER.style.display = "block";
        STATUS_MSG.innerText = "Requesting Camera Permission...";
        
        initAudio(); // Must start on user interaction
        
        // Android/Mobile explicit permission request logic often helps here
        navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } })
            .then((stream) => {
                VIDEO_Element.srcObject = stream;
                // Once stream is active, hand it to MediaPipe Camera Utils
                startCamera(); 
            })
            .catch((err) => {
                STATUS_MSG.innerText = "Camera Denied: " + err;
                LOADER.style.display = "none";
                START_BTN.style.display = "block";
            });
    });

</script>

</body>
</html>
